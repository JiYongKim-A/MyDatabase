# JVM의 구조, JVM동작 과정과 JAVA의 실행과정

## 목차 
## 1. [JVM이란](#1-jre-java-runtime-environment)

## 2. [JVM의 구조](#2-jdk-java-development-kit)

## 3. [JVM의 동작과정](#3-자바의-하위-호환성)

## 4. [Java의 실행과정](#4-자바의-버전별-특징-7-8-11)

## 5. [전체 정리](#5-정리본)

<br>

---

## 1. JVM(Java Virtual Machine)이란 
<img width="500" alt="스크린샷 2023-03-20 오전 11 04 31" src="https://user-images.githubusercontent.com/81874493/226295561-605f636a-f63a-4112-9ea5-d667d861db81.png">

<br>

 * 정의 : JVM은 자바 프로그램을(컴파일된 코드) 실행시키는 가상의 컴퓨터 입니다.
    
    ⇒ OS에 종속받지 않도록 OS위에서 Java를 실행 시키는 가상의 컴퓨터

<br>

* JVM의 역할
    * 자바 애플리케이션을 읽어들여 자바API와 함께 실행
    * Java와 OS 사이의 중개자 역할을 수행하여 OS에 종속받지 않고 독립적 실행을 가능케 한다.
    * Garbage Collector를 통해 Garbage Collection 수행

<br>

* JVM의 특징
    * 스택 기반의 가상머신 이다.
    
        가상 머신의 구현체는 명세서를 어떻게 구현하는가에 따라 여러 종류로 구분 된다

        <br>

        <details>
            <summary>[가상머신이 되기 위한 필요 조건]</summary>

        * 소스코드를 VM이 실행 가능한 바이트 코드로 변환이 가능 
        
            (명령어와 피연산자를 포함하는 데이터 구조를 포함 해야 한다) 
        
        <br>

        * 함수를 실행하기 위한 콜 스택이 존재해야 한다
        
        <br>
        
        * IP(Instruction Pointer) 존재
            * 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. ( = 프로그램 카운터(Program counter, PC))

        <br>

        * 가상 CPU
            * 다음 명령어를 패치 & 명령어를 해석 & 명령을 실행

        </details>

       
        
        >⇒ 위의 조건을 만족하는 가상머신을 구현하는 방법으로 `Stack 기반 가상머신`, `register 기반 가상머신`이 존재한다

        <br>

        <details>
            <summary>Stack 기반 가상머신</summary>

        * JVM이 Stack 기반 가상머신에 포함

        * 피연산자와 연산 후 결과를 스택에 저장한다.

        
        * 아래의 이미지와 같이 더하기 연산을 할 경우 Stack 구조이기 때문에 PUSH & POP 명령이 필요하다
            
            <br>
    
            <img width="500" alt="스크린샷 2023-03-20 오전 11 04 31" src="https://user-images.githubusercontent.com/81874493/229106854-91589b4d-8ff9-444c-974b-f304276ae70e.PNG">

        <br>

        * 장점

            * 하드웨어에 덜 의존적이다
            
                ⇒하드웨어(레지스터, CPU)에 대해 직접적으로 다루지 않기 때문에 다양한 하드웨어에서 쉽게 VM을 구현할 수 있다

            * 다음 피연산자의 메모리 위치를 기억할 필요가 없다.

                ⇒ SP(stack pointer)가 다음 피연산자의 위치를 나타낸다. 스택에서 POP을  하면 다음 피연산자가 나오기 때문에 피연산자의 메모리를 따로 기억할 필요가 없다.

            <br>
    
        * 단점
            * 명령어의 수가 많아진다
            * 스택을 사용하는 오버헤드가 존재한다
            * 명령어 최적화를 할 수 없다
            
        </details>

        <details>
            <summary>Register 기반 가상머신</summary>

        * Lua VM, Dalvik VM이 Register 기반 가상머신에 포함
        * 피연산자가 CPU의 레지스터에 저장된다
        * 피연산자를 레지스터에서 가져와서 계산한 뒤 다시 레지스터에 저장한다

        <br>
        
        * 장점
            * 명령어의 수가 적다 (PUSH&POP 명령없이 하나의 명령어로 계산이 가능히기 때문)
            * 스택을 사용하지 않아 스택에 대한 오버헤드가 없다
            * 명령어 최적화가 가능하다
                * 코드에 동일한 연산이 존재할때 처음 계산한 결과를 레지스터에 넣어 여러번 사용이 가능하다. (계산 비용 최적화)
        
        <br>

        * 단점
            * 명령어의 크기가 커진다
                ( 명령어에 피연산자의 메모리 주소를 작성해야 하기 때문에 길어진다.)
        </details>
        
         <br>

    * 심볼릭 레퍼런스 (Symbolic Reference)  

        기본 자료형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아닌 <U>**심볼릭 레퍼런스**</U>를 통해 참조한다.
        <details>
        <summary>Symbolic Reference란?</summary>

        자바는 동적 링킹(Dynamic Linking)을 사용하여 실행 가능한 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을
        
        >복사하지 않고, 해당 모듈의 주소만 가지고 있다가 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식을 사용합니다. 

        자바가 동적 링킹(Dynamic Linking)을 사용할 수 있는 이유는
        
        >.class 파일이 실행 가능한 형태가 아닌 JVM이 읽을 수 있는 형태 Java Byte Code 이기 때문입니다. class 파일은 JVM위에서 Linking 작업을 수행할 수 있도록, 라이브러리에 대한 Symbolic Reference만을 가지고 있게 됩니다.

        </details> 
    
    <br>
    

    * Garbage Collection(가비지 컬렉션)
        * 클래스의 인스턴스는 사용자 코드에 의해 명시적으로 생성되며 더 이상 참조하지 않는다면 GC(Garbage Collector)에 의해 자동으로 메모리를 반환한다.
    
    <br>

    * 플랫폼의 독립성 보장
        * C/C++등의 언어는 플랫폼에 따라 int형의 크기가 변한다

        >JVM은 기본 자료형을 명확히 정의해 호환성을 유지하며 플랫폼의 독립성을 보장한다.

    <br>
        
    * 네트워크 바이트 오더(network byte order)
      * 자바 클래스 파일은 네트워크 바이트 오더를 사용한다.
        > 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 <U>**플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다**</U>. 네트워크 바이트 오더는 빅 엔디안이다.
        
      * 네트워크 바이트 오더란?
          - 네트워크 상 데이터 전송시 연속되는 바이트를 저장하는데 사용되는 순서 = 바이트 저장 순서(Byte order)에 사용하는 규칙
          
          -  데이터 저장 방식에 따라 두가지로 구분
             - 빅 엔디안(Big Endian)
             - 리틀 엔디안(Little Endian)
            
        <br>

          - 네트워크 바이트 오더는 빅 엔디안이 가장 흔한 포멧
            - TCP, UDP, IPv4, IPv6과 같은 프로토콜은 빅 엔디안 방식 사용
            - 소켓 통신시 자주 사용되는 읽기/쓰기 함수들 경우 내부적으로 엔디안 변환 처리가 다 되어 있다. 
            
<br>

---

## 2. JVM의 구조
