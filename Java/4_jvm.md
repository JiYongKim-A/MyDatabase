# JVM의 구조, JVM동작 과정과 JAVA의 실행과정

## 목차 
## 1. [JVM이란](#1-jre-java-runtime-environment)

## 2. [Java의 실행과정](#4-자바의-버전별-특징-7-8-11)

## 3. [JVM의 구조](#2-jdk-java-development-kit)

## 4. [JVM의 동작과정](#3-자바의-하위-호환성)

## 5. [전체 정리](#5-정리본)

<br>

---

## 1. JVM(Java Virtual Machine)이란 
<img width="500" alt="스크린샷 2023-03-20 오전 11 04 31" src="https://user-images.githubusercontent.com/81874493/226295561-605f636a-f63a-4112-9ea5-d667d861db81.png">

<br>

 * 정의 : JVM은 자바 프로그램을(컴파일된 코드) 실행시키는 가상의 컴퓨터 입니다.
    
    ⇒ OS에 종속받지 않도록 OS위에서 Java를 실행 시키는 가상의 컴퓨터

<br>

* JVM의 역할
    * 자바 애플리케이션을 읽어들여 자바API와 함께 실행
    * Java와 OS 사이의 중개자 역할을 수행하여 OS에 종속받지 않고 독립적 실행을 가능케 한다.
    * Garbage Collector를 통해 Garbage Collection 수행

<br>

* JVM의 특징
    * 스택 기반의 가상머신 이다.
    
        가상 머신의 구현체는 명세서를 어떻게 구현하는가에 따라 여러 종류로 구분 된다

        <br>

        <details>
            <summary>[가상머신이 되기 위한 필요 조건]</summary>

        * 소스코드를 VM이 실행 가능한 바이트 코드로 변환이 가능 
        
            (명령어와 피연산자를 포함하는 데이터 구조를 포함 해야 한다) 
        
        <br>

        * 함수를 실행하기 위한 콜 스택이 존재해야 한다
        
        <br>
        
        * IP(Instruction Pointer) 존재
            * 마이크로프로세서(중앙 처리 장치) 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. ( = 프로그램 카운터(Program counter, PC))

        <br>

        * 가상 CPU
            * 다음 명령어를 패치 & 명령어를 해석 & 명령을 실행

        </details>

       
        
        >⇒ 위의 조건을 만족하는 가상머신을 구현하는 방법으로 `Stack 기반 가상머신`, `register 기반 가상머신`이 존재한다

        <br>

        <details>
            <summary>Stack 기반 가상머신</summary>

        * JVM이 Stack 기반 가상머신에 포함

        * 피연산자와 연산 후 결과를 스택에 저장한다.

        
        * 아래의 이미지와 같이 더하기 연산을 할 경우 Stack 구조이기 때문에 PUSH & POP 명령이 필요하다
            
            <br>
    
            <img width="500" alt="스크린샷 2023-03-20 오전 11 04 31" src="https://user-images.githubusercontent.com/81874493/229106854-91589b4d-8ff9-444c-974b-f304276ae70e.PNG">

        <br>

        * 장점

            * 하드웨어에 덜 의존적이다
            
                ⇒하드웨어(레지스터, CPU)에 대해 직접적으로 다루지 않기 때문에 다양한 하드웨어에서 쉽게 VM을 구현할 수 있다

            * 다음 피연산자의 메모리 위치를 기억할 필요가 없다.

                ⇒ SP(stack pointer)가 다음 피연산자의 위치를 나타낸다. 스택에서 POP을  하면 다음 피연산자가 나오기 때문에 피연산자의 메모리를 따로 기억할 필요가 없다.

            <br>
    
        * 단점
            * 명령어의 수가 많아진다
            * 스택을 사용하는 오버헤드가 존재한다
            * 명령어 최적화를 할 수 없다
            
        </details>

        <details>
            <summary>Register 기반 가상머신</summary>

        * Lua VM, Dalvik VM이 Register 기반 가상머신에 포함
        * 피연산자가 CPU의 레지스터에 저장된다
        * 피연산자를 레지스터에서 가져와서 계산한 뒤 다시 레지스터에 저장한다

        <br>
        
        * 장점
            * 명령어의 수가 적다 (PUSH&POP 명령없이 하나의 명령어로 계산이 가능히기 때문)
            * 스택을 사용하지 않아 스택에 대한 오버헤드가 없다
            * 명령어 최적화가 가능하다
                * 코드에 동일한 연산이 존재할때 처음 계산한 결과를 레지스터에 넣어 여러번 사용이 가능하다. (계산 비용 최적화)
        
        <br>

        * 단점
            * 명령어의 크기가 커진다
                ( 명령어에 피연산자의 메모리 주소를 작성해야 하기 때문에 길어진다.)
        </details>
        
         <br>

    * 심볼릭 레퍼런스 (Symbolic Reference)  

        기본 자료형을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아닌 <U>**심볼릭 레퍼런스**</U>를 통해 참조한다.
        <details>
        <summary>Symbolic Reference란?</summary>

        자바는 동적 링킹(Dynamic Linking)을 사용하여 실행 가능한 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을
        
        >복사하지 않고, 해당 모듈의 주소만 가지고 있다가 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식을 사용합니다. 

        자바가 동적 링킹(Dynamic Linking)을 사용할 수 있는 이유는
        
        >.class 파일이 실행 가능한 형태가 아닌 JVM이 읽을 수 있는 형태 Java Byte Code 이기 때문입니다. class 파일은 JVM위에서 Linking 작업을 수행할 수 있도록, 라이브러리에 대한 Symbolic Reference만을 가지고 있게 됩니다.

        </details> 
    
    <br>
    

    * Garbage Collection(가비지 컬렉션)
        * 클래스의 인스턴스는 사용자 코드에 의해 명시적으로 생성되며 더 이상 참조하지 않는다면 GC(Garbage Collector)에 의해 자동으로 메모리를 반환한다.
    
    <br>

    * 플랫폼의 독립성 보장
        * C/C++등의 언어는 플랫폼에 따라 int형의 크기가 변한다

        >JVM은 기본 자료형을 명확히 정의해 호환성을 유지하며 플랫폼의 독립성을 보장한다.

    <br>
        
    * 네트워크 바이트 오더(network byte order)
      * 자바 클래스 파일은 네트워크 바이트 오더를 사용한다.
        > 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 <U>**플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다**</U>. 네트워크 바이트 오더는 빅 엔디안이다.
        
      * 네트워크 바이트 오더란?
          - 네트워크 상 데이터 전송시 연속되는 바이트를 저장하는데 사용되는 순서 = 바이트 저장 순서(Byte order)에 사용하는 규칙
          
          -  데이터 저장 방식에 따라 두가지로 구분
             - 빅 엔디안(Big Endian)
             - 리틀 엔디안(Little Endian)
            
        <br>

          - 네트워크 바이트 오더는 빅 엔디안이 가장 흔한 포멧
            - TCP, UDP, IPv4, IPv6과 같은 프로토콜은 빅 엔디안 방식 사용
            - 소켓 통신시 자주 사용되는 읽기/쓰기 함수들 경우 내부적으로 엔디안 변환 처리가 다 되어 있다. 
            
<br>


---
## 2. Java의 실행 과정
<img width="500" alt="https://user-images.githubusercontent.com/81874493/231426896-450f565e-2c12-4f6d-b6d2-ca8b7f9f6138.png">

1. 작성한 자바 소스(java source), 즉 확장자가 .java인 파일을 자바 컴파일러(Java Compiler)를 통해 자바 바이트 코드(Java Byte Code)로 컴파일 한다.
2. 컴파일된 바이트 코드를 JVM 클래스 로더(Class Loader)에게 전달한다.
3. 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM 메모리에 올린다.
4. 실행 엔진(Execution Egine)은 JVM메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 실행한다.


<br>

---

## 3. JVM의 구조
    
<img width="500" alt="스크린샷 2023-03-20 오전 11 04 31" src="https://user-images.githubusercontent.com/81874493/231420535-f0aa6561-873c-4404-bd73-d3d10f58bcff.png">

- 클래스 로더
- 런타임 데이터 영역
- 실행 엔진

<br>

### 클래스 로더 (Class Loader)
- 클래스 로더란
- 클래스 로더의 특징
  - 계층구조
  - Delegation 원칙
  - 가시성 제한
  - 언로드 불가
  - 이름 공간
- 클래스 로딩 과정

<br>

### 런타임 데이터 영역 (Runtime Data Areas)
